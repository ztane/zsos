; PROG.ASM

eli assembloijaan 16 bittisellä ...
jeh toi on aika selkeä käsky kuitenki :)
[BITS 16]
[ORG 0]
ja oletetaan offsetti 0 tähän :d
segmentillä ei siis väliä?
no ei koska siis sehän on implisiittisesti se mikä käskylle kuuluu
ok

nonii sitten ne segmenttideskriptorit... näissä menee pää kipiäksi
eli 32flattitilassa segmentit merkataan tällasilla struktuureilla :D:D
augh mulla meinas tulla jo aneurysma eile ku kattelin näitä se vaatii
sellasen 3 tuntii mutta sitten ku sen iffaa ni seon iha helppo :d
if u say so :) 

eli tuossa on toi low word of the segment length,
nii siinä on 16 bittiä, sitten on base addressin 16 bittiä
sitten basen 8 seuraavaa bittiä, flageja
sitten segmentin pituuven 4 suurinta bittiä ja basen 8 bittiä

ts base osote on 32bittiä, mutta segmentin pituuteen on vaa 20bittiä,
osaakko selittää miksi? ...miettii... syy on se että ne segmenttilimitit
on sivun tarkkuudella (12bittiä). tuosta huomaa että globaaleille segmenteille
ei voi käyttää ku 4 gigatavua :/ tai no ehkä en tiä mutta vois tweakata
7.99 gigatavua maks yht. osotettavaa muistia. ELi gdt ei riitä jos 
joka prosessille pitää antaa 4gigaa muistavaruutta :d -->>niiiii?????
heh, koitan sisäistää näitä max. tehokkaasti. mutta koita sen verran antaa anteeksi
, koska nyt tutustun ekaa kertaa tällä tarkkuudella x86 muistiavaruutee :P
mutta mutta... kyl nämä tästä no mää tutustuin eilen :D:D
 nää oletkin nero :) 

tosiaan noissa accessflageissa sitten sanotaan myös
että saako lukee ja kirjottaa ja tms... nii sitten prosessori enforseaa
että jos koodisegmentiksi lukee sellasen johon saa kirjottaa nii tulee heti
segv :D ok eli ne on tossa "access" hommelissa.
siinä voi myös sanoo että mikä on exec ja mikä on nonexec segmentti
esmes vois laittaa meijjän käytttikseen että siellä olis toinen datasegmentti
joka olis exec :D
hmm eli, koodisegmentit r-x, stack ja heap rw-?suunnalleen...

STRUC segment_descriptor
  seg_length0_15:	resw 1		; low word of the segment length
  base_addr0_15:	resw 1		; low word of base address
  base_addr16_23:	resb 1		; low byte of high word of base addr.
  flags:		resb 1		; segment type and misc. flags
  access:		resb 1		; highest nibble of segment length
  					; and access flags
  base_addr24_31:	resb 1		; highest byte of base address
ENDSTRUC

sitten interrupt descriptor tableen... eli siinä kerrotaan
protnmoden intvektori... 32bittinen lineaarinen osote 16bittisessä 
selektorissa + jotain paskoja lippuja... yht 8 tavua :d
--> ok. pikkuhiljaa "ehkä" alkaa sisäistää tän segmenttimallin
eli noita on 256 tuettu i386sssa max...

--> blah en koita ite järkeillä, siitä ei tuu mitää :)
no vetää esmes descriptorin 80h -> omaan syscall vektoriin :d
ok olin siis oikeilla jäljillä loppuje lopuks.

noilla flagiella visii sääjetään etät pystyykö sitä trigaaman softalla
...mikä lienee suht olennaista, jos käytetää sitä syscalleihi
ja en haluais pystyy trigaamana pagefaultteja käsin int-rajapinnalla
tai sanoon että näppiksellä on tavaraa... aye toi on melko selkeää kauraa

STRUC interrupt_descriptor
  .offset0_15:		resw	1		; low word of handler offset
  .selector0_15:	resw	1		; segment selector
  .zero_byte:		resb	1		; unused in this descriptor format
  .flags:		resb	1		; flag-byte
  .offset16_31:		resw	1		; high word of handler offset
ENDSTRUC

nonii tässä on se mitä varsinaisesti aletaan assembloimaan...
eli 9000: ladataan tää, veetään ax:ään cs, ja alustetaan muut segmentit
sp = 8000h, on jotain 25kiloo tilaa enneku se alkaa jyrsiin meidän koodia...
siihen vois tieten liattaaa että seolis esmes ss 8000 ja sp 0ffffh :d

        mov ax, cs
        mov ds, ax
        mov es, ax
	mov ss, ax
    	mov sp, 8000h

--->> 25k riittänee tässä vaiheessa? vähemmälläkin on tultu toimee... :)muttaku 
seolis iha sama melkee vetää se sinne 8000h :d

        xor bx, bx
        mov ah, 3
        int 10h             ; get cursor position to dh, dl

kuiten, taas kursor possi

        mov ah, 13h         ; Print "===="
        mov al, 1           ;
        mov bx, 7h          ;
        mov cx, end-string  ;
        mov bp, string      ;
        int 10h             ;

ja printataan stringi... "Loading Ztanix..." hehe :D
hih. selkeä. muistuttaa suht paljo linukan syscallia write.

sitten se A20 line :D:d
eli A20 gate on se näppis kontrollerissa oleva systeemi joka andataan 
osotelinjan A20 (A20line) kanssa :d :D:D
 apua :D

eli ku x86sessa ei ollu a20 linjaa vaan vaa 0-19 linjat...
nii siinä se "HMA" eli segmentti FFFF:n offsetit
10-FFFF wrappautuu segmenttiin 0... ja 286 sitten oletuksena
tietne joutu toimiin samoin :d ---> ja se ei olisi hyväksi...
no jos joku softa luottaa siihen... sen takia jokku ibmän
insinöörit keksi että näppiskontrollerissa on yks ylimääränen
ohjelmoitava nasta, nimesivät sen A20 Gateksi ja se andataan
A20:n kanssa... ja normaalisti seon disabloitu :D:D:D:D
eli A20 on aina nolla :D:D kätsää :D

kipiää :) ja vielä kipeempää on että jos ilman a20sta nakkaa
protekted moden nii pystyy addressoimaa vaa parittomia megatavuja :D
koska sei vaikuta muihin osotelinjoihin!!! :DD:D
SICK :;D

himem.sys enabloi vissiin unrealmoden tai jonku ja nakkaa myös
A20gaten päälle dossissa... mutta bios ei sitä tee ni se pitää
tehrä käsin :d:D joko nyt älyytt miks mikkisofta on paska :D:D
kyl. 


A20Address:
	; Set A20 Address line here
    	CLI
        CALL enableA20
    	STI

        JMP continue
enableA20:
        call enableA20o1

        jnz  enableA20done
        mov  al,   0d1h
        out  64h,  al

        call enableA20o1
        jnz  enableA20done

        mov  al,   0dfh
        out  60h,  al

enableA20o1:
        mov ecx, 20000h

enableA20o1l:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop

        in     al, 64h
        test   al, 2
        loopnz enableA20o1l
enableA20done:
        ret

eli tossa enabloidaan a20 portittamalla sitä NÄPPÄIMISTÖKONTROLLERIA!!!!
ja nopit on sen takia, että se ehtis reagoeiia?k
siinä oli jump... muta luulin ettei se toiminu :D:D lähinnä kiusataan kakhea...
miks ihmeessä?
älä multa kysy :D

continue:
;        xor bx, bx
;        mov ah, 3
;        int 10h             ; get cursor position to dh, dl

;        mov ah, 13h         ; Print "===="
;        mov al, 1           ;
;        mov bx, 7h          ;
;        mov cx, end-string  ;
;        mov bp, string      ;
;        int 10h             ;

sitte ny alkaa hauska juttu. Ladataan nimittäin global descriptor table :D:d
segmentti datasegmentti, offsetti gdt_reg... --> ? --> load global descriptor table?
tms? jeps...

	 lgdt	[ds:gdt_reg]
	cli
clear interrupts...

ny alkaa se hauskin... eli movataan eaxiin control register 0 :D josta en ole vielä
kuullutkaan :) no siinä on kaikkee paskaa... emmää itekkää tiiä...

 	mov     eax, cr0
    	or      eax, 1
        mov     cr0, eax

laitetaan bitti 1 (protected mode) päälle... ja japusketaa se takasi? jeh...
olisko? :d jepjep.hmm. mitäs tämä seuraava, jmp laalaa, jossa sit db 0x66, 0xea?
tupakan mittanen tauko, afk 5min ja heti sitten takas öööööh....

ok takas.. jah äijät alko ihmeellä flamettaa eroa GNU/Linux:n ja linuxin välillä :)
ja GNU Hurd jne. heh. ja tuli muute helvetin vahva deja-vu tästä tilanteesta yhtäkkiä
takasi-->_-_>->_->---->-->_->--->_---===========>

---> ACK? jep
hlooo... hitto tuo isleoki on aika...

jeh olen kuulolla :)
jep...
eli katoppa jmp intoflat kiusaa taas kakhea :d:d
eli sillä saahaan tuo flushautummaan nuo asiat tms. :D
gnnnn koitan tajuta :D
nonii... sitten tuossa
    	jmp     intoflat

intoflat:

	prefix 66h tarkottaa 32bittistä addressoimista eiku 32bittisiä rekistereitä
	eli kato ny ollaan vielä 16 bittisessä segmentissä :D:D:D LOL
	sitä segmenttiä ei oo vielä vaihettu... siks tehään 32 bittinen jumppi
	(66 ea) osotteeseen 08:09prot, missä 08 on uus koodisegmentin 
	*selektori* ok

	eli katos, äsken oltiin 16bitttisessä segmentissä 9000h:0000
	jota vastaa lineaarinen osote 090000h. Siihen lisätääjn vielä
	offsetti tohon prottiin, saadaan osote 09ooooh... 
	ok? ---> jotakuinki ok. siis, mulla tahtoo vieläki mennä aivot solmuu ton
	segmentoidun muistin kanssa.. jos pystyt heittää linkin, jossa siitä
	kerrotaan hieman, niin tämä olis paljo helpompaa kauraa mulle :)
	(koitan kokoaja päässä verrata tätä esim. TI86 24bit paged memory mallii)
	ei oo sivutettua :D:D (VIELÄ)
	eli kato siellä gdtssä voi sanoo että onko siellä koodisegmentissä
	16 vai 32bittistä koodia :D::D:Dd:D:D LOL...
	ny ollaan 16bittisessä koodisegmentissä nii pitää tehdä hyppy 32
	bittiseen nii seon koodattu tuolleen tavuilla :D:D jekh 
se	n tajusin jo :). mutta siis. yleisesti tuo muistin segmentointi tahtoo
	vääntää vielä ajatukset solmuu no mennään eteen päin...jep
	flat memorymodel on loppujenlopuksi kuiten hlepompi :D
	mutta se siirtymienn on avian VITU NVAIKEETA
	tottakai.

	db      066h, 0eah
        dw      prot, 09h
        dw      08h

[BITS 32]
prot:   ; Set up segments
	jeps... eli ny ollaa nsiellä :D:d bits 32 
	32 bittinen koodisegmentti ja flat memory model
	---> nogs. eli cs = 08h
	ladataan ebxään 10h, ladataan ds, es, fs ja gs selektorit
	ok? jeh. jaksakko sanoa vielä, että mitenkä:
	ds: data segment (selector)?
	es: ? extra --->
	fs: fs, gs -> ei kukaan tiiä mutta f ja g tulee d:n ja e:n jälkee :D:D
	ok pointti on siinä että segmenttirekisterin lataaminen kestää vitusti
	koska se tekee ne access checkit samalla...
	mutta sen läpi osottamienn on nopeeta.
	eli pitemmän päälle säästää?
	nii siis NIITÄ EI VOI KÄYTTÄÄ DATAA ilman että nää osotat segmentti
	rekisterin läpi... yleensä ooperaatiot defaulttaa ds läpi
	ok tämä selvitti taas paljon :) siks niitä lisättiin 2 että
	jos tarvii useita hanskata nii säästää kelloja
	ah.

        mov ebx, 10h
        mov ds, bx
        mov es, bx
        mov fs, bx
        mov gs, bx

	nonii kaikki selektorit on asetettu paitsi SS...

	no ny on helppo kirjottaa näytölle. Näyttö alkaa lineaarisessa muistissa
	osotteesta 0b8000h. ladataan se ebxään ja veetään sen läpi tavaraa :D:D
	mov ebx, 0b8000h
	mov byte [ebx], 'H'
	mov byte [ebx + 2], 'e'
	mov byte [ebx + 4], 'l'
	mov byte [ebx + 6], 'l'
	mov byte [ebx + 8], 'o'
...> ....> ok? yeh, tämä on selkeää tavaraa. erittäinkin. lineaarinen muistimalli
mahtuu mulla päähän kuitenki paljo paremmin. sen kanssa kun olen työskennelly aiemmi.
haha, äijä tylyttää ihmeellä.
vitu ääliö toi isleo oikeestaan ... 
liian idealistinen sanoisin. jos idealismi alkaa olee softabisneksessä tärkeempää, ku
ohjelman toimivuus, niin jotain on vialla. :|
Windowsia on turvallista dissata (sanotaan ny näin) GNU/Linux:n rinnalla, koska se on
oikeasti huonompaa softaa. Ei sen vuoksi, että se on suljettua koodia.
nii macossia pitää jumaloijja :D:D
heh. no Mac on ok. Ne on saanu aikaa ihan toimivan systeemin, mikäs siinä :)
jos ois rahaa nii voisin vaikka ostaakki Mac:i
*BSD:stä en sano mitään, ku en ole koskaa käyttäny.


eli tuossa aseteteaan ss, veetään selektori 18 siihen...
ja lineaarinen osote 90000h - eli 16bit segmentin
9000h yläosa... (-4 tieten)...
ok. eli alustetaan stack?
ni... ei hä sitä tarvi alustaa ::D:D: varisnaisesti
espiin ei vissii voi vetää immediatea... ku on laitettu eax ensin...
nogs, "alustetaan" olis ollu parempi muoto
jaa..
        ; Set up stack segment
        mov ebx, 18h
        mov ss, bx
        mov eax, 90000h - 4
        mov esp, eax

noni... sitten pushataan arvo...
joka menis argumenttina, movataan ebx:ään lineaarinen osote 91000h
eli just 4096 tavuu eteen päin ja callataan sitä :D:D tämä selvä.
katotaanpa ne selektorit ny. sopii.

16:09·03 <@joneskoo> Isleo: pidät vai et ole kokeillut parempia?
16:09·12 <@Isleo> joneskoo: olen kokeillut ja pidän siitä.
16:09·23 <@Ztane> Isleo: olet siis kokeillu parempiaki :d

----->>>> 
        push eax
        mov ebx, 91000h
        call ebx

hang:                       ; Hang!
        hlt

;;; GDT DATA

string: db 13, 10, "Loading Ztanix...", 13, 10
end:

        dd 0

tuossa on se gdt-struktuuri, eli se kertoo taulun koon
tavuina, sitten sen alkuosotteen, 090400h lineaarinen...
---> ok.
gdt_reg: dw gdt_size, 0400h, 09h

times 1024-($-$$) db 0
eli tasasin nää 1024-tasalle...

ja sitten ne deskriptorit. Ekaksi tällanen 0-deskriptori
joka on vähän niinku nullpointteri, senku lataa nii menee vitulleen kiakki :d
heh. mihin tätä sit tarvitaa. no evt vielä... mutta iha hyvä...
kato nii noi selectorien arvot siis tulee suoraan tavuihin tän taulun sisällä
eli tää on deskriptori 0...
dummy_dscr:	istruc segment_descriptor
	at seg_length0_15, dw 0
   	at base_addr0_15,  dw 0 
  	at base_addr16_23, db 0     
	at flags,          db 0 
  	at access,         db 0  
  	at base_addr24_31, db 0  
iend

sitten 8 tavua myöhemmin deskriptori 8: 
HLOOO... sdfsndogfssdfsdfsdf sdfluen noita arvoja menemää
eelli tässä on codesegment descriptor...
joo... eli limitti on ffff + access-arvosta fh
+ sitten pagen tarkkuudella eli koko 4 gigaa.
base osote on 0h lineaarista muistia
nyt se tarkottaa että looginen ja fyysinen muisti ton selektorin
läpi on samoissa osotteissa ilman pagetusta... pagetus tulis ton
alle :D:D tämä selvä.
code32_dscr: istruc segment_descriptor
	at seg_length0_15, dw 0ffffh
   	at base_addr0_15,  dw 0
  	at base_addr16_23, db 0     
	at flags,          db 09ah 
  	at access,         db 0cfh  
  	at base_addr24_31, db 0  
iend

sitten datasegmentti - huomaa erona vaan se että flagit on erit
eli rw jne... jep :) ja taas tästä voi addressoijja 4 gigaa
lineaarista muistia 0sta eteenpäin :d
data32_dscr: istruc segment_descriptor
	at seg_length0_15, dw 0ffffh
   	at base_addr0_15,  dw 0
  	at base_addr16_23, db 0     
	at flags,          db 092h 
  	at access,         db 0cfh  
  	at base_addr24_31, db 0  
iend

ja core, joka laattiin ss:ään... alias datadeskriptorille
ts samat kontentit jne... mutta *voitas* mapata muualle 
tämän käyttötarkotus ois?laattiin ss:ään...
ah
core32_dscr: istruc segment_descriptor
	at seg_length0_15, dw 0ffffh
   	at base_addr0_15,  dw 0
  	at base_addr16_23, db 0     
	at flags,          db 092h 
  	at access,         db 0cfh  
  	at base_addr24_31, db 0  
iend

sitten 16bittiset kode ja datasegmentit, eli erona on se
että noista pääsee vetään vaa ekat 16bittiä... + defaulttaa
16bittiseen koodiin ja dataan... :D ok.

code16_dscr: istruc segment_descriptor
	at seg_length0_15, dw 0ffffh
   	at base_addr0_15,  dw 0
  	at base_addr16_23, db 0     
	at flags,          db 09ah 
  	at access,         db 0  
  	at base_addr24_31, db 0  
iend

data16_dscr: istruc segment_descriptor
	at seg_length0_15, dw 0ffffh
   	at base_addr0_15,  dw 0
  	at base_addr16_23, db 0     
	at flags,          db 092h 
  	at access,         db 0  
  	at base_addr24_31, db 0  
iend

gdt_size EQU $-dummy_dscr

times 4192-($-$$) db 0

sitten tasataan... UPS...
tuossa on VIRHE :D:D hypättiin nimittäin about 96 tavua liian 
aikasi, onneksi 0 = brk grin.eiku mikä vittu seoli
ADD r/m8,reg8                 ; 00 /r                [8086] 
jep... tuo...
eli se lisää rekisteriä muistiin :D:D GRIN
yhtä tavua :D:d
nollasivulle :D:D:D LOL :D:D
anyways...
ookkonää vielä siellä :D

ny :D -> jatka vain.
